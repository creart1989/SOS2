<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Patrick Stanke Theater Spiel</title>
<style>
  body, html { margin: 0; padding: 0; overflow: hidden; background: #222; }
  canvas { display: block; margin: 0 auto; background: #111; image-rendering: pixelated; }
  #ui {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    color: white; font-family: 'Arial Black', Arial, sans-serif; font-size: 18px;
    text-align: center; user-select: none;
    z-index: 100;
  }
  #message {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: white; font-family: 'Arial Black', Arial, sans-serif; font-size: 24px;
    background: rgba(0,0,0,0.8); padding: 20px 40px; border-radius: 10px;
    display: none;
    z-index: 200;
  }
  #controls {
    position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%);
    z-index: 100;
  }
  .btn {
    background: #444; border: none; color: white; font-size: 24px;
    padding: 15px 20px; margin: 0 10px; border-radius: 8px;
    user-select: none;
  }
  .btn:active {
    background: #888;
  }
</style>
</head>
<body>
<div id="ui">
  Level: <span id="level">1</span> &nbsp;&nbsp; Leben: <span id="lives">3</span> &nbsp;&nbsp; Notenblätter: <span id="score">0</span>
</div>

<div id="message"></div>

<div id="controls">
  <button id="leftBtn" class="btn">◀</button>
  <button id="jumpBtn" class="btn">▲</button>
  <button id="rightBtn" class="btn">▶</button>
</div>

<canvas id="game" width="480" height="320"></canvas>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const W = canvas.width;
  const H = canvas.height;

  // UI elements
  const levelUI = document.getElementById('level');
  const livesUI = document.getElementById('lives');
  const scoreUI = document.getElementById('score');
  const message = document.getElementById('message');

  // Touch buttons
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');

  // --- Game constants ---
  const GRAVITY = 0.6;
  const FLOOR_Y = H - 40;  // Theater floor y position
  const PLAYER_SPEED = 3;
  const JUMP_POWER = 12;
  const MAX_LEVEL = 20;
  const INITIAL_LIVES = 3;

  // --- Assets (simplified cartoon style sprites) ---
  // For demo, we draw everything with canvas shapes (no images)
  // Patrick Stanke-like cartoon figure with simple colors & shapes

  // --- Game state ---
  let level = 1;
  let lives = INITIAL_LIVES;
  let score = 0;
  let gameOver = false;
  let gameWon = false;

  // Player object
  const player = {
    x: 50,
    y: FLOOR_Y,
    width: 32,
    height: 48,
    vy: 0,
    onGround: true,
    direction: 1, // 1 right, -1 left
    alive: true,
    animationFrame: 0,
  };

  // Controls state
  const keys = {
    left: false,
    right: false,
    jump: false,
  };

  // Touch control handlers
  leftBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.left = true; });
  leftBtn.addEventListener('touchend', e => { e.preventDefault(); keys.left = false; });

  rightBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.right = true; });
  rightBtn.addEventListener('touchend', e => { e.preventDefault(); keys.right = false; });

  jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); if(player.onGround) keys.jump = true; });
  jumpBtn.addEventListener('touchend', e => { e.preventDefault(); keys.jump = false; });

  // Keyboard handlers
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && player.onGround) keys.jump = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = false;
  });

  // --- Level data ---
  // For demo: levels have platforms (x, y, width, height), enemies and collectibles

  function generateLevelData(levelNum) {
    // Creates platforms, enemies, and notes for level

    // Platform example: stage floors/platforms in theater style, higher platforms
    let platforms = [
      {x: 0, y: FLOOR_Y, width: W, height: 40}, // floor

      // additional random platforms for each level
    ];

    // Add some platforms at different heights
    for(let i=0; i < Math.min(levelNum+2, 6); i++) {
      let px = 40 + i * 70 + Math.sin(levelNum+i)*50;
      let py = FLOOR_Y - 60 - i*40;
      platforms.push({x: px, y: py, width: 100, height: 15});
    }

    // Enemies - bad critics or tomatoes
    let enemies = [];
    for(let i=0; i < levelNum + 1; i++) {
      let ex = 100 + i * 90 + (levelNum % 3)*20;
      let ey = FLOOR_Y - 40;
      enemies.push({
        x: ex,
        y: ey,
        width: 30,
        height: 30,
        direction: i % 2 === 0 ? 1 : -1,
        speed: 1 + levelNum * 0.1,
        range: 80 + (i * 10),
        startX: ex,
      });
    }

    // Collectibles - Notenblätter
    let notes = [];
    for(let i=0; i < 3 + Math.floor(levelNum/2); i++) {
      let nx = 80 + i * 120;
      let ny = FLOOR_Y - 100 - (i % 2) * 40;
      notes.push({x: nx, y: ny, width: 20, height: 20, collected: false});
    }

    // Level end area
    let goal = {
      x: W - 60,
      y: FLOOR_Y - 80,
      width: 40,
      height: 80
    };

    return {platforms, enemies, notes, goal};
  }

  let currentLevelData = generateLevelData(level);

  // --- Helper functions ---
  function rectsIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.width || 
             r2.x + r2.width < r1.x || 
             r2.y > r1.y + r1.height ||
             r2.y + r2.height < r1.y);
  }

  // --- Draw functions ---

  function drawBackground() {
    // Theater backdrop with curtains
    ctx.fillStyle = '#330000';
    ctx.fillRect(0, 0, W, H);

    // Curtains
    ctx.fillStyle = '#660000';
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.bezierCurveTo(100, 150, 150, 0, 240, 0);
    ctx.bezierCurveTo(330, 0, 380, 150, 480, 0);
    ctx.lineTo(480, 80);
    ctx.bezierCurveTo(350, 120, 300, 50, 240, 50);
    ctx.bezierCurveTo(180, 50, 130, 120, 0, 80);
    ctx.closePath();
    ctx.fill();

    // Stage floor
    ctx.fillStyle = '#4a2f10';
    ctx.fillRect(0, FLOOR_Y, W, H - FLOOR_Y);
  }

  function drawPlatforms() {
    ctx.fillStyle = '#8B4513'; // wood color
    currentLevelData.platforms.forEach(p => {
      ctx.fillRect(p.x, p.y, p.width, p.height);
    });
  }

  function drawPlayer() {
    const p = player;
    ctx.save();

    // Draw shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(p.x + p.width/2, p.y + p.height + 6, p.width/2, 8, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.translate(p.x + p.width/2, p.y + p.height/2);
    if (p.direction === -1) ctx.scale(-1,1);

    // Body
    ctx.fillStyle = '#222'; // black jacket
    ctx.fillRect(-12, -20, 24, 36);

    // Head - cartoon face (patrick-stanke-like)
    ctx.fillStyle = '#f4d1b2'; // skin
    ctx.beginPath();
    ctx.ellipse(0, -30, 12, 14, 0, 0, Math.PI*2);
    ctx.fill();

    // Hair (simple)
    ctx.fillStyle = '#330000';
    ctx.beginPath();
    ctx.moveTo(-12,-40);
    ctx.quadraticCurveTo(0,-50,12,-40);
    ctx.lineTo(12,-20);
    ctx.quadraticCurveTo(0,-30,-12,-20);
    ctx.closePath();
    ctx.fill();

    // Eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(-5,-32,3,2,0,0,Math.PI*2);
    ctx.ellipse(5,-32,3,2,0,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(-5,-32,1,1,0,0,Math.PI*2);
    ctx.ellipse(5,-32,1,1,0,0,Math.PI*2);
    ctx.fill();

    // Mouth
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-5, -20);
    ctx.quadraticCurveTo(0,-15,5,-20);
    ctx.stroke();

    ctx.restore();
  }

  function drawEnemies() {
    currentLevelData.enemies.forEach(enemy => {
      // Draw simple tomato or bad critic cartoon

      // Tomato enemy (red round with green leaf)
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.ellipse(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/2, enemy.height/2, 0, 0, Math.PI*2);
      ctx.fill();

      // Leaf
      ctx.fillStyle = 'green';
      ctx.beginPath();
      ctx.moveTo(enemy.x + enemy.width/2, enemy.y + enemy.height/2 - enemy.height/2);
      ctx.lineTo(enemy.x + enemy.width/2 + 8, enemy.y + enemy.height/2 - enemy.height/2 - 6);
      ctx.lineTo(enemy.x + enemy.width/2 - 8, enemy.y + enemy.height/2 - enemy.height/2 - 6);
      ctx.closePath();
      ctx.fill();

      // Eyes angry
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(enemy.x + 6, enemy.y + 12);
      ctx.lineTo(enemy.x + 12, enemy.y + 6);
      ctx.moveTo(enemy.x + enemy.width - 6, enemy.y + 12);
      ctx.lineTo(enemy.x + enemy.width - 12, enemy.y + 6);
      ctx.stroke();
    });
  }

  function drawNotes() {
    currentLevelData.notes.forEach(note => {
      if (!note.collected) {
        ctx.fillStyle = '#fffde7';
        ctx.fillRect(note.x, note.y, note.width, note.height);

        // Draw musical note symbol (simple)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(note.x + 6, note.y + note.height);
        ctx.lineTo(note.x + 6, note.y + 6);
        ctx.quadraticCurveTo(note.x + 12, note.y + 2, note.x + 16, note.y + 8);
        ctx.stroke();
      }
    });
  }

  function drawGoal() {
    const g = currentLevelData.goal;
    ctx.fillStyle = '#ffe066';
    ctx.fillRect(g.x, g.y, g.width, g.height);

    ctx.fillStyle = '#a66a00';
    ctx.font = 'bold 20px Arial';
    ctx.fillText('EXIT', g.x + 5, g.y + g.height - 10);
  }

  // --- Game logic ---

  function updatePlayer() {
    if(!player.alive) return;

    // Horizontal movement
    if (keys.left) {
      player.x -= PLAYER_SPEED;
      player.direction = -1;
    }
    if (keys.right) {
      player.x += PLAYER_SPEED;
      player.direction = 1;
    }

    // Prevent leaving screen horizontally
    if(player.x < 0) player.x = 0;
    if(player.x + player.width > W) player.x = W - player.width;

    // Gravity
    player.vy += GRAVITY;
    player.y += player.vy;

    // Collision with platforms
    player.onGround = false;
    for(const p of currentLevelData.platforms) {
      if (player.y + player.height > p.y &&
          player.y + player.height < p.y + p.height &&
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.vy >= 0) {
        player.y = p.y - player.height;
        player.vy = 0;
        player.onGround = true;
        break;
      }
    }

    // Jumping
    if (keys.jump && player.onGround) {
      player.vy = -JUMP_POWER;
      player.onGround = false;
      keys.jump = false; // jump only once per press
    }
  }

  function updateEnemies() {
    currentLevelData.enemies.forEach(enemy => {
      enemy.x += enemy.speed * enemy.direction;
      if (enemy.x > enemy.startX + enemy.range) enemy.direction = -1;
      if (enemy.x < enemy.startX) enemy.direction = 1;
    });
  }

  function checkCollisions() {
    // Player - enemies
    for(const enemy of currentLevelData.enemies) {
      if(rectsIntersect(player, enemy)) {
        loseLife();
        break;
      }
    }

    // Player - notes
    currentLevelData.notes.forEach(note => {
      if(!note.collected && rectsIntersect(player, note)) {
        note.collected = true;
        score++;
        scoreUI.textContent = score;
      }
    });

    // Player - goal
    if(rectsIntersect(player, currentLevelData.goal)) {
      if(level < MAX_LEVEL) {
        level++;
        levelUI.textContent = level;
        resetLevel();
      } else {
        // game won
        gameWon = true;
        showMessage('Herzlichen Glückwunsch! Du hast alle Level geschafft!');
      }
    }
  }

  function loseLife() {
    if (!player.alive) return;
    lives--;
    livesUI.textContent = lives;
    if(lives <= 0) {
      player.alive = false;
      gameOver = true;
      showMessage('Game Over! Keine Leben mehr. Reload für Neustart.');
    } else {
      // respawn player at start
      player.x = 50;
      player.y = FLOOR_Y - player.height;
      player.vy = 0;
    }
  }

  function resetLevel() {
    currentLevelData = generateLevelData(level);
    player.x = 50;
    player.y = FLOOR_Y - player.height;
    player.vy = 0;
  }

  function showMessage(txt) {
    message.textContent = txt;
    message.style.display = 'block';
  }

  function hideMessage() {
    message.style.display = 'none';
  }

  // --- Main game loop ---
  function loop() {
    if (!gameOver && !gameWon) {
      updatePlayer();
      updateEnemies();
      checkCollisions();
    }

    // Draw everything
    drawBackground();
    drawPlatforms();
    drawGoal();
    drawNotes();
    drawEnemies();
    if(player.alive) drawPlayer();

    requestAnimationFrame(loop);
  }

  // Start the game
  function startGame() {
    level = 1;
    lives = INITIAL_LIVES;
    score = 0;
    gameOver = false;
    gameWon = false;
    player.alive = true;

    levelUI.textContent
