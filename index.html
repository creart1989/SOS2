<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Patrick Stanke Cartoon Plattformer</title>
<style>
  body, html {
    margin:0; padding:0; overflow: hidden; background: #222;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
  }
  canvas {
    display: block; margin: 0 auto; background: linear-gradient(to top, #1b2735 0%, #090a0f 100%);
    border: 3px solid #555;
  }
  #ui {
    color: #eee; font-size: 20px; text-align:center; margin:10px;
  }
</style>
</head>
<body>

<div id="ui">Level: 1 | Noten gesammelt: 0</div>
<canvas id="gameCanvas" width="800" height="450"></canvas>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Steuerung
  const keys = {
    left: false,
    right: false,
    up: false,
  };

  window.addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') keys.up = true;
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') keys.up = false;
  });

  // Level-Daten: Plattformen (x, y, width, height), Sammelobjekte (x,y)
  // Verschiedene Hintergründe für die Level (einfach farblich unterschiedlich)
  const levels = [
    {
      bgColorTop: '#152238',
      bgColorBottom: '#0b1527',
      platforms: [
        {x: 0, y: 420, w: 800, h: 30},
        {x: 120, y: 350, w: 130, h: 20},
        {x: 320, y: 300, w: 120, h: 20},
        {x: 520, y: 250, w: 130, h: 20},
        {x: 700, y: 190, w: 80, h: 20},
      ],
      notes: [
        {x: 150, y: 320, collected: false},
        {x: 350, y: 270, collected: false},
        {x: 550, y: 220, collected: false},
        {x: 730, y: 160, collected: false},
      ]
    },
    {
      bgColorTop: '#382b1f',
      bgColorBottom: '#1a130a',
      platforms: [
        {x: 0, y: 420, w: 800, h: 30},
        {x: 100, y: 360, w: 100, h: 20},
        {x: 270, y: 310, w: 100, h: 20},
        {x: 440, y: 270, w: 120, h: 20},
        {x: 620, y: 220, w: 140, h: 20},
      ],
      notes: [
        {x: 130, y: 330, collected: false},
        {x: 300, y: 280, collected: false},
        {x: 480, y: 240, collected: false},
        {x: 660, y: 190, collected: false},
      ]
    },
    {
      bgColorTop: '#2a252e',
      bgColorBottom: '#1d1923',
      platforms: [
        {x: 0, y: 420, w: 800, h: 30},
        {x: 50, y: 360, w: 90, h: 20},
        {x: 180, y: 310, w: 130, h: 20},
        {x: 370, y: 270, w: 150, h: 20},
        {x: 590, y: 230, w: 140, h: 20},
        {x: 780, y: 180, w: 20, h: 20},
      ],
      notes: [
        {x: 80, y: 330, collected: false},
        {x: 230, y: 280, collected: false},
        {x: 460, y: 240, collected: false},
        {x: 620, y: 200, collected: false},
        {x: 785, y: 160, collected: false},
      ]
    }
  ];

  let currentLevel = 0;
  let score = 0;

  // Spielfigur - Patrick Stanke Cartoon Style
  const player = {
    x: 50,
    y: 0,
    w: 40,
    h: 70,
    vx: 0,
    vy: 0,
    speed: 3.5,
    jumpPower: 11,
    onGround: false,
    facingRight: true,
  };

  const gravity = 0.55;
  const maxFallSpeed = 15;

  // UI Element
  const ui = document.getElementById('ui');

  // Kollisionsfunktion AABB (axis aligned bounding box)
  function collide(rect1, rect2) {
    return rect1.x < rect2.x + rect2.w &&
           rect1.x + rect1.w > rect2.x &&
           rect1.y < rect2.y + rect2.h &&
           rect1.y + rect1.h > rect2.y;
  }

  // Zeichenfunktion: Plattform
  function drawPlatform(p) {
    ctx.fillStyle = '#604020';
    ctx.shadowColor = 'rgba(0,0,0,0.7)';
    ctx.shadowBlur = 8;
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.shadowBlur = 0;
  }

  // Zeichne Sammelobjekt (goldene Note)
  function drawNote(note) {
    if (note.collected) return;

    const cx = note.x;
    const cy = note.y;

    // großer gelber Kreis als Basis
    ctx.fillStyle = '#FFD700';
    ctx.shadowColor = 'rgba(255,215,0,0.9)';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.ellipse(cx, cy, 15, 20, 0, 0, Math.PI * 2);
    ctx.fill();

    // Noten-Kopf (kleiner Kreis)
    ctx.beginPath();
    ctx.ellipse(cx + 12, cy - 22, 6, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Noten-Stiel (Stab)
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#B8860B';
    ctx.beginPath();
    ctx.moveTo(cx + 15, cy - 12);
    ctx.lineTo(cx + 15, cy - 60);
    ctx.stroke();

    ctx.shadowBlur = 0;
  }

  // Patrick Stanke cartoon zeichnen
  function drawPatrick(p) {
    const x = p.x;
    const y = p.y;
    const w = p.w;
    const h = p.h;

    ctx.save();
    ctx.translate(x + w/2, y + h);

    // Flip, wenn nach links schaut
    ctx.scale(p.facingRight ? 1 : -1, 1);

    // Körper: schwarzer Anzug mit weißen Details
    ctx.fillStyle = '#111';
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-w/4, 0);
    ctx.lineTo(-w/4, -h * 0.7);
    ctx.lineTo(w/4, -h * 0.7);
    ctx.lineTo(w/4, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Hemdkragen weiß
    ctx.fillStyle = '#eee';
    ctx.beginPath();
    ctx.moveTo(-w/8, -h * 0.7);
    ctx.lineTo(0, -h * 0.8);
    ctx.lineTo(w/8, -h * 0.7);
    ctx.closePath();
    ctx.fill();

    // Kopf (rund, etwas oval)
    ctx.fillStyle = '#f2d7b3'; // Hautfarbe
    ctx.strokeStyle = '#a67c52';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.ellipse(0, -h * 0.95, w/4, h/4.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Haare: dunkelbraun, voluminös nach hinten
    ctx.fillStyle = '#3d2b1f';
    ctx.beginPath();
    ctx.moveTo(-w/4, -h * 1.15);
    ctx.bezierCurveTo(-w/4, -h * 1.5, w/4, -h * 1.5, w/4, -h * 1.15);
    ctx.lineTo(w/4, -h * 1.05);
    ctx.bezierCurveTo(0, -h * 1.2, -w/8, -h * 1.05, -w/4, -h * 1.05);
    ctx.closePath();
    ctx.fill();

    // Bartschatten (leicht grau)
    ctx.fillStyle = 'rgba(50,50,50,0.5)';
    ctx.beginPath();
    ctx.ellipse(0, -h * 0.8, w/6, h/20, 0, 0, Math.PI * 2);
    ctx.fill();

    // Augen (braun)
    ctx.fillStyle = '#462f14';
    ctx.beginPath();
    ctx.ellipse(-w/12, -h * 0.95, w/24, h/40, 0, 0, Math.PI * 2);
    ctx.ellipse(w/12, -h * 0.95, w/24, h/40, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pupillen (schwarz)
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(-w/12, -h * 0.95, w/80, h/80, 0, 0, Math.PI * 2);
    ctx.ellipse(w/12, -h * 0.95, w/80, h/80, 0, 0, Math.PI * 2);
    ctx.fill();

    // Mund (leicht lächelnd)
    ctx.strokeStyle = '#643200';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(-w/16, -h * 0.85);
    ctx.quadraticCurveTo(0, -h * 0.82, w/16, -h * 0.85);
    ctx.stroke();

    ctx.restore();
  }

  // Spielzustand und Logik

  function resetLevel() {
    const lvl = levels[currentLevel];
    player.x = 50;
    player.y = lvl.platforms[0].y - player.h;
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    score = 0;
    for (const note of lvl.notes) {
      note.collected = false;
    }
  }

  // Grenzen prüfen, damit Spieler nicht aus dem Bildschirm läuft
  function clampPlayer() {
    if (player.x < 0) player.x = 0;
    if (player.x + player.w > WIDTH) player.x = WIDTH - player.w;
    if (player.y > HEIGHT) {
      // Spieler fällt runter -> Level zurücksetzen
      resetLevel();
    }
  }

  // Update
  function update() {
    const lvl = levels[currentLevel];

    // Bewegung horizontal
    if (keys.left) {
      player.vx = -player.speed;
      player.facingRight = false;
    } else if (keys.right) {
      player.vx = player.speed;
      player.facingRight = true;
    } else {
      player.vx = 0;
    }

    // Springen
    if (keys.up && player.onGround) {
      player.vy = -player.jumpPower;
      player.onGround = false;
    }

    // Schwerkraft
    player.vy += gravity;
    if (player.vy > maxFallSpeed) player.vy = maxFallSpeed;

    // Neue Position
    player.x += player.vx;
    player.y += player.vy;

    // Kollision mit Plattformen (von oben)
    player.onGround = false;
    for (const p of lvl.platforms) {
      if (
        player.vy >= 0 &&
        player.x + player.w > p.x &&
        player.x < p.x + p.w &&
        player.y + player.h > p.y &&
        player.y + player.h < p.y + p.h
      ) {
        player.y = p.y - player.h;
        player.vy = 0;
        player.onGround = true;
      }
    }

    clampPlayer();

    // Sammelobjekte einsammeln
    for (const note of lvl.notes) {
      if (!note.collected) {
        const noteRect = {x: note.x - 15, y: note.y - 20, w: 30, h: 40};
        const playerRect = {x: player.x, y: player.y, w: player.w, h: player.h};
        if (collide(playerRect, noteRect)) {
          note.collected = true;
          score++;
        }
      }
    }

    // Level fertig wenn alle Noten gesammelt
    if (score === lvl.notes.length) {
      currentLevel++;
      if (currentLevel >= levels.length) {
        alert('Herzlichen Glückwunsch! Du hast alle Level geschafft!');
        currentLevel = 0;
      }
      resetLevel();
    }

    // UI aktualisieren
    ui.textContent = `Level: ${currentLevel + 1} | Noten gesammelt: ${score}`;
  }

  // Hintergrund zeichnen (Gradient)
  function drawBackground() {
    const lvl = levels[currentLevel];
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, lvl.bgColorTop);
    grad.addColorStop(1, lvl.bgColorBottom);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  // Zeichnen
  function draw() {
    drawBackground();

    const lvl = levels[currentLevel];
    for (const p of lvl.platforms) {
      drawPlatform(p);
    }
    for (const note of lvl.notes) {
      drawNote(note);
    }

    drawPatrick(player);
  }

  // Game Loop
  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  resetLevel();
  loop();

})();
</script>

</body>
</html>
