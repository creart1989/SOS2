<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Theater-Moonwalker mit Patrick Stanke</title>
<style>
  body {
    margin: 0; background: #111; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white;
  }
  #gameCanvas {
    background: linear-gradient(to top, #2b0d0d 0%, #5e1f1f 80%, #a34040 100%);
    display: block; margin: 0 auto; border: 5px solid #a34040;
  }
  #ui {
    text-align: center; margin-top: 10px; font-weight: bold;
  }
  #message {
    position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8); padding: 20px 40px; border-radius: 10px; font-size: 1.5em;
    display: none; color: #ffcc00;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="480" height="320"></canvas>
<div id="ui">
  Level: <span id="level">1</span> &nbsp;&nbsp; Leben: <span id="lives">3</span> &nbsp;&nbsp; Noten: <span id="notes">0</span>/<span id="notesGoal">0</span>
</div>
<div id="message"></div>

<script>
// --- Globale Variablen ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

let level = 1;
let lives = 3;
let notesCollected = 0;
let notesGoal = 0;

const GRAVITY = 0.5;
const FRICTION = 0.8;

let keys = {};

// --- Spielfigur (Patrick Stanke im Moonwalker-Stil) ---
class Player {
  constructor() {
    this.width = 40;
    this.height = 60;
    this.x = 50;
    this.y = HEIGHT - this.height - 40;
    this.vx = 0;
    this.vy = 0;
    this.speed = 3.5;
    this.jumping = false;
    this.onGround = false;
    this.color = '#e8c07a'; // Hautfarbe
  }

  draw() {
    // Körper (wie Patrick Stanke im stilisierten Moonwalker-Look)
    ctx.save();
    ctx.translate(this.x, this.y);

    // Kopf
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.ellipse(20, 15, 15, 20, 0, 0, Math.PI * 2);
    ctx.fill();

    // Haare (dunkelbraun)
    ctx.fillStyle = '#4b2e0d';
    ctx.beginPath();
    ctx.ellipse(20, 5, 18, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Körper (schwarzer Anzug mit rotem Schal)
    ctx.fillStyle = '#000';
    ctx.fillRect(5, 35, 30, 50);
    ctx.fillStyle = '#b03030';
    ctx.fillRect(5, 35, 30, 10); // Schal

    // Beine (schwarz)
    ctx.fillStyle = '#000';
    ctx.fillRect(5, 85, 15, 25);
    ctx.fillRect(20, 85, 15, 25);

    // Schuhe (dunkelgrau)
    ctx.fillStyle = '#222';
    ctx.fillRect(3, 110, 20, 10);
    ctx.fillRect(20, 110, 20, 10);

    ctx.restore();
  }

  update() {
    // Bewegung links/rechts
    if (keys['ArrowRight'] || keys['d']) {
      this.vx = this.speed;
    } else if (keys['ArrowLeft'] || keys['a']) {
      this.vx = -this.speed;
    } else {
      this.vx *= FRICTION;
      if (Math.abs(this.vx) < 0.1) this.vx = 0;
    }

    // Springen
    if ((keys['ArrowUp'] || keys['w'] || keys[' ']) && this.onGround) {
      this.vy = -10;
      this.jumping = true;
      this.onGround = false;
    }

    this.vy += GRAVITY;

    this.x += this.vx;
    this.y += this.vy;

    // Begrenzung Bildschirm
    if (this.x < 0) this.x = 0;
    if (this.x + this.width > WIDTH) this.x = WIDTH - this.width;

    // Boden
    if (this.y + this.height > HEIGHT - 40) {
      this.y = HEIGHT - 40 - this.height;
      this.vy = 0;
      this.jumping = false;
      this.onGround = true;
    }
  }
}

// --- Plattform ---
class Platform {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h;
  }
  draw() {
    ctx.fillStyle = '#4e2c1a';
    ctx.fillRect(this.x, this.y, this.width, this.height);
    // Rote Theatervorhang-Kante
    ctx.strokeStyle = '#b03030';
    ctx.lineWidth = 3;
    ctx.strokeRect(this.x, this.y, this.width, this.height);
  }
}

// --- Sammelobjekte (Notenblätter) ---
class Note {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 20;
    this.collected = false;
  }
  draw() {
    if (this.collected) return;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.rect(this.x, this.y, this.size, this.size * 1.4);
    ctx.fill();

    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x + 4, this.y + 5);
    ctx.lineTo(this.x + 4, this.y + this.size * 1.3);
    ctx.moveTo(this.x + 10, this.y + 7);
    ctx.lineTo(this.x + 10, this.y + this.size * 1.1);
    ctx.moveTo(this.x + 16, this.y + 9);
    ctx.lineTo(this.x + 16, this.y + this.size * 0.9);
    ctx.stroke();
  }
  checkPickup(px, py, pw, ph) {
    if (this.collected) return false;
    if (
      px < this.x + this.size &&
      px + pw > this.x &&
      py < this.y + this.size * 1.4 &&
      py + ph > this.y
    ) {
      this.collected = true;
      return true;
    }
    return false;
  }
}

// --- Gegner (Tomaten oder schlechte Kritiker) ---
class Enemy {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.width = 35;
    this.height = 30;
    this.vx = 1.5;
    this.direction = 1;
    this.color = '#d22';
  }
  draw() {
    ctx.fillStyle = this.color;
    // Tomate: roter Kreis mit Gesicht
    ctx.beginPath();
    ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, 17, 15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Augen
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(this.x + 12, this.y + 10, 5, 7, 0, 0, Math.PI * 2);
    ctx.ellipse(this.x + 22, this.y + 10, 5, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pupillen
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(this.x + 12, this.y + 10, 2, 3, 0, 0, Math.PI * 2);
    ctx.ellipse(this.x + 22, this.y + 10, 2, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Mund (grimmig)
    ctx.strokeStyle = '#330000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x + 10, this.y + 25);
    ctx.lineTo(this.x + 25, this.y + 25);
    ctx.stroke();
  }
  update(platforms) {
    this.x += this.vx * this.direction;

    // Gegner bewegt sich auf Plattformen hin und her
    let onPlatform = false;
    for (let p of platforms) {
      if (
        this.x + this.width > p.x &&
        this.x < p.x + p.width &&
        this.y + this.height === p.y
      ) {
        onPlatform = true;
        break;
      }
    }
    if (!onPlatform) {
      // Richtungswechsel wenn Gegner vom Rand fällt
      this.direction *= -1;
      this.x += this.vx * this.direction;
    }

    // Bildschirmrand begrenzung
    if (this.x < 0 || this.x + this.width > WIDTH) {
      this.direction *= -1;
      this.x += this.vx * this.direction;
    }
  }
  checkCollision(px, py, pw, ph) {
    if (
      px < this.x + this.width &&
      px + pw > this.x &&
      py < this.y + this.height &&
      py + ph > this.y
    ) {
      return true;
    }
    return false;
  }
}

// --- Level Definitionen ---
const levels = [
  {
    platforms: [
      new Platform(0, HEIGHT - 40, WIDTH, 40), // Boden
      new Platform(60, 240, 120, 15),
      new Platform(200, 190, 130, 15),
      new Platform(360, 140, 110, 15),
    ],
    notes: [
      new Note(100, 210),
      new Note(250, 160),
      new Note(400, 110),
    ],
    enemies: [
      new Enemy(70, 205),
      new Enemy(220, 155),
    ],
  },
  {
    platforms: [
      new Platform(0, HEIGHT - 40, WIDTH, 40),
      new Platform(50, 230, 100, 15),
      new Platform(180, 180, 120, 15),
      new Platform(330, 130, 130, 15),
      new Platform(420, 80, 50, 15),
    ],
    notes: [
      new Note(75, 200),
      new Note(200, 150),
      new Note(380, 100),
      new Note(435, 50),
    ],
    enemies: [
      new Enemy(55, 225),
      new Enemy(340, 125),
    ],
  },
  {
    platforms: [
      new Platform(0, HEIGHT - 40, WIDTH, 40),
      new Platform(80, 210, 140, 15),
      new Platform(260, 160, 120, 15),
      new Platform(420, 110, 50, 15),
    ],
    notes: [
      new Note(110, 180),
      new Note(290, 130),
      new Note(440, 80),
    ],
    enemies: [
      new Enemy(90, 205),
      new Enemy(280, 155),
      new Enemy(430, 100),
    ],
  },
];

// Max Level
const MAX_LEVEL = levels.length;

// --- Spielobjekte ---
let player;
let currentLevel;
let platforms;
let notes;
let enemies;

// --- UI Elemente ---
const levelLabel = document.getElementById('level');
const livesLabel = document.getElementById('lives');
const notesLabel = document.getElementById('notes');
const notesGoalLabel = document.getElementById('notesGoal');
const messageBox = document.getElementById('message');

function resetLevel(lvl) {
  currentLevel = lvl;
  player = new Player();
  platforms = levels[lvl - 1].platforms;
  notes = levels[lvl - 1].notes;
  enemies = levels[lvl - 1].enemies;
  notesCollected = 0;
  notesGoal = notes.length;

  levelLabel.textContent = lvl;
  livesLabel.textContent = lives;
  notesLabel.textContent = notesCollected;
  notesGoalLabel.textContent = notesGoal;

  messageBox.style.display = 'none';
}

function gameOver() {
  messageBox.textContent = 'Du hast alle Leben verloren! Spiel vorbei.';
  messageBox.style.display = 'block';
}

function nextLevel() {
  if (level < MAX_LEVEL) {
    level++;
    resetLevel(level);
  } else {
    messageBox.textContent = 'Glückwunsch! Du hast alle Level geschafft!';
    messageBox.style.display = 'block';
  }
}

function update() {
  player.update();

  // Kollisionsabfrage Spieler <-> Plattformen
  player.onGround = false;
  for (let p of platforms) {
    // AABB collision detection
    if (
      player.x < p.x + p.width &&
      player.x + player.width > p.x &&
      player.y + player.height < p.y + 10 &&
      player.y + player.height + player.vy >= p.y
    ) {
      player.y = p.y - player.height;
      player.vy = 0;
      player.onGround = true;
      player.jumping = false;
    }
  }

  // Kollision Spieler <-> Notenblätter
  for (let n of notes) {
    if (n.checkPickup(player.x, player.y, player.width, player.height)) {
      notesCollected++;
      notesLabel.textContent = notesCollected;
    }
  }

  // Kollision Spieler <-> Gegner
  for (let e of enemies) {
    e.update(platforms);
    if (e.checkCollision(player.x, player.y, player.width, player.height)) {
      // Spieler verliert ein Leben und Level neu starten
      lives--;
      livesLabel.textContent = lives;
      if (lives <= 0) {
        gameOver();
        return;
      } else {
        resetLevel(level);
        return;
      }
    }
  }

  // Level geschafft?
  if (notesCollected >= notesGoal) {
    nextLevel();
  }
}

function draw() {
  // Hintergrund - Bühne, rot-gestreift mit Vorhang
  ctx.clearRect(0, 0, WIDTH, HEIGHT);

  // Theater-Vorhang am oberen Rand
  let curtainHeight = 60;
  let curtainGradient = ctx.createLinearGradient(0, 0, 0, curtainHeight);
  curtainGradient.addColorStop(0, '#8b0000');
  curtainGradient.addColorStop(1, '#4b0000');
  ctx.fillStyle = curtainGradient;
  ctx.fillRect(0, 0, WIDTH, curtainHeight);

  // Bühne (Boden)
  ctx.fillStyle = '#3e1f0f';
  ctx.fillRect(0, HEIGHT - 40, WIDTH, 40);

  // Plattformen zeichnen
  for (let p of platforms) {
    p.draw();
  }

  // Notenblätter zeichnen
  for (let n of notes) {
    n.draw();
  }

  // Gegner zeichnen
  for (let e of enemies) {
    e.draw();
  }

  // Spieler zeichnen
  player.draw();
}

function loop() {
  update();
  draw();
  if (lives > 0) requestAnimationFrame(loop);
}

// --- Eingabe-Events ---
window.addEventListener('keydown', (e) => {
  keys[e.key] = true;
});

window.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

// --- Spiel starten ---
resetLevel(level);
loop();

</script>

</body>
</html>